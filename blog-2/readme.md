# 关于六边形架构的思考

## 什么是六边形架构?

六边形架构，又名端口与适配器架构，很多人认为用端口和适配器架构这个名称更合适，而采用六边形，是为了通过**可视化**的方式强调：
- 架构中内外部区域的区别。
- 不同端口间的相似性。
- 呈现一定数量的不同端口。

并不是因为“六”这个数字有多重要，而是为了让人们画图时有足够的空间摆放所需的端口和适配器，而不会受到一维层次结构的限制，术语“六边形架构”正是由这一图形而得名。

<img src="./images/hexagonal-architecture.jpeg" width="560">

而术语“端口与适配器”则是针对该架构的“目的”而命名的。一个端口确定了一个有目的的会话。一个端口可以有多个适配器，根据不同的技术实现，将对应的适配器”插入“这个端口。

## 六边形架构的意图

在六边形架构中，当客户请求抵达时，一个基于特定技术的适配器(adapter)会将客户输入进行转化并适配到一个端口(port)，然后端口将调用应用(application)的某个操作，而应用则对输入设备一无所知。输出时，应用会将信息通过一个端口发往适配器，适配器再针对信息接受者的具体技术将其转化成合适的输出信号。应用在输入输出时，只和相应的适配器进行语意完整的交互，而不知道适配器另一端的具体技术是什么。

这样做的意图是让应用(application)能够以一致的方式被用户、程序、自动化测试、批处理脚步所驱动；并且，可以在与实际运行的设备和数据库相隔离的情况下开发和测试。

## 六边形架构的两个区域

在传统的分层架构中，我们所有的依赖项都会指向一个方向，上面的每一层都会依赖自己下面的层，我们会以上下的顺序来看待每层。但是，六边形架构提倡用一种新的视角来看待整个系统，六边形架构中存在两个区域，分别是**外部区域**和**内部区域**，外部区域处理**与外部实体间的交互**，内部区域处理**业务逻辑**，所有依赖项都指向中心区域。

### 外部区域

外部区域即外部六边形区域，在外部区域中，不同的客户均可以提交输入。每种类型的客户都有它自己的适配器(adapter)，该适配器用于将客户输入转化为程序内部区域所能理解的输入。

### 内部区域

内部区域即内部六边形区域，内部区域包含了应用程序和领域模型，应用程序是领域模型的直接客户。内部六边形的边界也即应用程序边界，也是用例（用户故事）边界。在使用六边形架构时，我们应该按照功能需求来设计内部区域中的应用程序，而不是根据客户请求的输入输出机制。

### 内外部区域如何沟通？

六边形的每条不同的边代表了不同种类型的端口，端口要么处理输入，要么处理输出。内部六边形的端口是六边形架构中外部区域与内部区域沟通的唯一渠道。用户可根据不同的技术实现，将对应的适配器”插入“这个端口，这样便实现了内部区域与外部区域的解耦。

### 六边形架构必须遵循的规则

**与”内部“相关的代码不能泄露到”外部“去**。也就是业务逻辑代码不能泄露到与外部实体间交互的地方去。如果业务逻辑泄露到了外部，则会出现内部区域依赖外部区域的情况，这样就无法保证外部是可以替换的。

## 端口到底是什么？

在《实现领域驱动设计》书中对六边形架构中的端口有这样的描述：
> 端口没有明确的定义，它是一个非常灵活的概念；通常来说我们都不用自己实现端口。我们可以将端口想成是HTTP，而将适配器想成Java的Servlet或JAX-RS的REST请求处理。或者，我们可以为NServiceBus或RabbitMQ创建消息监听器，在这种情况下，端口是消息机制，而适配器则是消息监听器，因为消息监听器将负责从消息中提取数据，并将数据转化为应用层API所需的参数；六边形的每条不同的边代表了不同种类型的端口；

书中说端口可以是HTTP，适配器是REST请求处理，如Contoller；端口可以是消息机制，适配器是消息监听器，如EventHandler。似乎在说六边形的每条边代表了不同的通讯协议。

我的理解是六边形架构中有两个六边形，而这段描述主要是针对外部六边形而言的。六边形的每条不同的边代表了不同种类型的端口，也就是说每条边上可以有多个端口，而每条边上的端口应该是同类型的。端口的划分非常灵活，这里使用了不同的通讯协议来划分外部六边形的端口类型。

如六边形架构图中有所示，有3个客户请求均抵达相同的输入端口（外部六边形的边），另一个客户请求使用了适配器D。可能前3个请求使用了HTTP协议，而后一个请求使用了AMQP协议。

对于内部六边形来说，它的每条边也代表了不同种类型的端口，通常通过业务来划分内部六边形端口类型。而适配器将外部六边形端口信息转化成了内部六边形端口所能理解的信息。

**每条不同的边代表了不同种类型的端口，这样做的意义是可视化不同端口间的相似性**。如果我们不关注这一点那么六边形架构则可以用洋葱架构来代替。

## 六边形架构左右侧的区别

六边形架构使用的是正六边形，它是一种对称图形，六边形架构用每条边代表不同种类型的端口，六边形架构有意地装作所有端口在本质上是一样的，这是为了让架构的关注点聚焦在架构中内外部区域的区别，而不是左右或上下的区别。而在实现上，则可将端口和适配器分为两类：“主（primary）”、“从（secondary）”适配器，也可称为“驱动（driving）”和“被驱动（driven）”适配器。

这与用例中的 “主参与者（primary actors）” 和 “从参与者（secondary acors）” 的思想有关。 “主参与者” 驱动应用运行。“从参与者” 则被应用所驱动，用于返回一个结果或仅仅是被通知而已。“主”和“从”的区别在于，谁驱动应用程序的会话。

我们可以根据系统的 “用例语境图”绘制端口和适配器。将“主端口”和“主适配器”画在六边形的左侧或上方；将“从端口”或“从适配器”画在六边形的右侧下方。

## 内部六边形的端口

有些人认为内部六边形中的端口是独立的一个层，他们将内部区域分为端口层(port)、应用层(application)和领域层(domain)，他们认为外部区域和内部区域都要依赖于端口，端口层中所有的端口都应由接口来定义，其设计的项目代码结构大概如下：
```
src/com/example
  - adapters
    - primary
      - rest
    - secondary
      - persistence
        - MysqlThingsRepository
  - domain
  - application
  - ports
    - primary
      - ThingsService (interface)
    - secondary
      - ThingsRepository (interface)
```

虽然将ports单独出来有助于方便查看所有的端口定义，但是这样的意义并不大。我认为端口是内部区域（应用和领域模型）提供用来与外部区域沟通的，端口应该属于应用或者领域模型。有些情况下主(primary)端口未必非得是一个接口(interface)，它完全可以是一个类(class)，这种情况下我们要为了ports创建一个接口吗？

而从(secondary)端口则需要是一个接口，因为对于从适配器实际上内部依赖外部，这需要使用依赖倒置，由主适配器将从适配器注入到应用内部，这时端口的定义在应用内部，但是实现由适配器实现。即便从端口需要是一个接口，但也不意味着应该将端口独立出来，repository在DDD中就是属于domain层。

在没用充足的理由下，我们应该将端口放置在和它们关系最为密切的地方，而不是以类型来决定它们应该放置到哪里。这样做项目代码结构大概如下：

```
src/com/example
  - adapters
    - primary
      - rest
    - secondary
      - persistence
        - MysqlThingsRepository
  - domain
    - model
      - Things
      - ThingsRepository (interface)
    - service
  - application
    - service
      - ThingsService (interface/class)
```

## 分层架构与六边形架构

现在，很多声称使用分层架构的团队实际上使用的是六边形架构。这是因为很多项目都使用了某种形式的依赖注入。并不是说依赖注入天生就是六边形架构，而是说使用了依赖注入的架构自然的具有了端口与适配器风格。

如果我们故意放大六边形架构中特意忽略的左侧与右侧的区别，将六边形从中间分开，那么你会发现被分开的六边形架构和使用了依赖注入的分层架构非常的相似。六边形架构与分层架构的主要区别在于六边形架构主要关注在外部区域和内部区域，并规定与”内部“相关的代码不能泄露到”外部“去，以实现外部的可替换性。

## 知道这些有何用？

了解了这些似乎只是让人明白了为何这个架构叫六边形架构，但重点是了解这些有助于你分辨分层架构、洋葱架构、端口与适配器架构、六边形架构之间细微的不同和它们的关注点，从而根据你项目的情况选择合适的架构或对架构进行相应的裁剪。

## 参考
本文有大部分内容摘自：
- 【翻译】六边形架构: https://zhuanlan.zhihu.com/p/113681224
- 《实现领域驱动设计》

如想对六边形架构有更深的理解，请阅读上面链接相关的内容。